\chapter{Разработанный код}
\label{ch:chap2}

Исходный код на GitHub:

https://github.com/Denisqu/masters-practice-sem2

\section{K-RLE}

Представим разработанные алгоритмы кодирования и декодирования K-RLE на языке программирования Python:

\begin{lstlisting}[language=python, caption=K-RLE реализация на языке Python, captionpos=b, frame=single]
    from typing import List

    def k_rle_code(stream: List[int], K: int) -> List[int]:
        # Функция для кодирования потока чисел с использованием модифицированного RLE алгоритма.
        # 
        # Алгоритм:
        # 1. Проходим по входному потоку чисел.
        # 2. Если элемент повторяется (учитывая допустимое отклонение K), увеличиваем счетчик повторов.
        # 3. Если элемент не повторяется, вставляем текущие накопленные повторы в результат.
        # 4. В конце вставляем оставшиеся элементы после завершения цикла.
        # 
        # Аргументы:
        # stream -- входной поток чисел
        # K -- допустимое отклонение для повторяющихся чисел
        # 
        # Возвращает:
        # Закодированный поток чисел

        result_stream = []
        count = 0
        repeat_count = 0
        ST = 0
        
        def insert_func():
            if repeat_count < 4:
                result_stream.extend([ST] * (repeat_count + 1))
            else:
                result_stream.extend([repeat_count, ST])
        
        for i, newT in enumerate(stream):
            count += 1
            if count == 1:
                ST = newT
                continue
            if (newT + K > ST and newT - K < ST) or newT == ST:
                repeat_count += 1
                continue
            insert_func()
            repeat_count = 0
            ST = newT
        insert_func()
            
        return result_stream
    
    def k_rle_decode(stream: List[int], threshold: int) -> List[int]:
        # Функция для декодирования потока чисел, закодированного модифицированным RLE алгоритмом.
        #
        # Алгоритм:
        # 1. Проходим по входному закодированному потоку чисел.
        # 2. Если элемент меньше порога и больше 0, считаем его как количество повторов и добавляем соответствующие элементы в результат.
        # 3. Если элемент не является счетчиком повторов, просто добавляем его в результат.
        # 4. Переходим к следующему элементу.
        #
        # Аргументы:
        # stream -- входной закодированный поток чисел
        # threshold -- порог для определения счетчиков повторов
        #
        # Возвращает:
        # Декодированный поток чисел
        
        result_stream = []
        i = 0
        while i < len(stream):
            if stream[i] < threshold and stream[i] > 0:
                result_stream.extend([stream[i+1]] * (stream[i] + 1))
                i += 2
            else:
                current = stream[i]
                result_stream.append(current)
                i += 1
        return result_stream
    
\end{lstlisting}

\section{LTC}

Представим разработанный алгоритм кодирования
LTC на языке программирования Python:

\begin{lstlisting}[language=python, caption=ltc реализация на языке Python, captionpos=b, frame=single]

    from typing import List, Tuple

    def ltc_code(data_stream: List[Tuple[int, int]], e: int) -> List[Tuple[int, int]]:
        # Алгоритм:
        # 1. Инициализация: получение первой точки данных, сохранение её в z. Получение следующей точки (t2, v2),
        #    использование её для инициализации границ UL (верхняя граница) и LL (нижняя граница).
        # 2. Вычисление highLine как линии, соединяющей z и UL.
        # 3. Вычисление lowLine как линии, соединяющей z и LL.
        # 4. Получение следующей точки данных. Преобразование точки в вертикальный сегмент с использованием погрешности e.
        #    Определение ul как верхней точки сегмента и ll как нижней точки сегмента.
        # 5. Если highLine находится ниже ll или lowLine находится выше ul, переход к шагу 9, иначе продолжение.
        # 6. Если highLine выше ul, установка UL в ul.
        # 7. Если lowLine ниже ll, установка LL в ll.
        # 8. Переход к шагу 2.
        # 9. Завершение: вывод z в выходной поток данных.
        # 10. Установка z как точки, находящейся посередине между UL и LL.
        # 11. Установка UL как ul.
        # 12. Установка LL как ll.
        # 13. Переход к шагу 2.
    
        def calculate_line(p1: Tuple[float, float], p2: Tuple[int, int])
         -> Tuple[int, int]:
            #Вычисляет коэффициенты прямой, проходящей через две точки (p1 и p2)
            x1, y1 = p1
            x2, y2 = p2
            slope = (y2 - y1) / (x2 - x1)
            intercept = y1 - slope * x1
            return slope, intercept
    
        result_stream = []
        z = data_stream[0]
        t2, v2 = data_stream[1]
        UL = (t2, v2 + e)
        LL = (t2, v2 - e)
        i = 2
    
        while i < len(data_stream):
            highLine = calculate_line(z, UL)
            lowLine = calculate_line(z, LL)
            t, v = data_stream[i]
            ul = (t, v + e)
            ll = (t, v - e)
            
            slope_high, intercept_high = highLine
            slope_low, intercept_low = lowLine
            
            if (slope_high * t + intercept_high < ll[1]) 
            or (slope_low * t + intercept_low > ul[1]):
                result_stream.append(z)
                z = ((UL[0] + LL[0]) / 2, (UL[1] + LL[1]) / 2)
                UL = ul
                LL = ll
            else:
                if slope_high * t + intercept_high > ul[1]:
                    UL = ul
                if slope_low * t + intercept_low < ll[1]:
                    LL = ll
    
            i += 1
    
        result_stream.append(z)
        
        return result_stream
\end{lstlisting}


\endinput