\chapter{Разработанный код}
\label{ch:chap2}

\section{K-RLE}

Представим разработанные алгоритмы кодирования и декодирования K-RLE на языке программирования Python:
\begin{lstlisting}[language=python, caption=K-RLE реализация на языке Python, captionpos=b, frame=single]
    from typing import List

    def k_rle_code(stream: List[int], K: int) -> List[int]:
        # Функция для кодирования потока чисел с использованием модифицированного RLE алгоритма.
        # 
        # Алгоритм:
        # 1. Проходим по входному потоку чисел.
        # 2. Если элемент повторяется (учитывая допустимое отклонение K), увеличиваем счетчик повторов.
        # 3. Если элемент не повторяется, вставляем текущие накопленные повторы в результат.
        # 4. В конце вставляем оставшиеся элементы после завершения цикла.
        # 
        # Аргументы:
        # stream -- входной поток чисел
        # K -- допустимое отклонение для повторяющихся чисел
        # 
        # Возвращает:
        # Закодированный поток чисел

        result_stream = []
        count = 0
        repeat_count = 0
        ST = 0
        
        def insert_func():
            if repeat_count < 4:
                result_stream.extend([ST] * (repeat_count + 1))
            else:
                result_stream.extend([repeat_count, ST])
        
        for i, newT in enumerate(stream):
            count += 1
            if count == 1:
                ST = newT
                continue
            if (newT + K > ST and newT - K < ST) or newT == ST:
                repeat_count += 1
                continue
            insert_func()
            repeat_count = 0
            ST = newT
        insert_func()
            
        return result_stream
    
    def k_rle_decode(stream: List[int], threshold: int) -> List[int]:
        # Функция для декодирования потока чисел, закодированного модифицированным RLE алгоритмом.
        #
        # Алгоритм:
        # 1. Проходим по входному закодированному потоку чисел.
        # 2. Если элемент меньше порога и больше 0, считаем его как количество повторов и добавляем соответствующие элементы в результат.
        # 3. Если элемент не является счетчиком повторов, просто добавляем его в результат.
        # 4. Переходим к следующему элементу.
        #
        # Аргументы:
        # stream -- входной закодированный поток чисел
        # threshold -- порог для определения счетчиков повторов
        #
        # Возвращает:
        # Декодированный поток чисел
        
        result_stream = []
        i = 0
        while i < len(stream):
            if stream[i] < threshold and stream[i] > 0:
                result_stream.extend([stream[i+1]] * (stream[i] + 1))
                i += 2
            else:
                current = stream[i]
                result_stream.append(current)
                i += 1
        return result_stream
    
\end{lstlisting}

\endinput